---
layout: post
title:  "ES6知识要点及常用特性梳理"
date:   2017-06-29 13:20:00
categories: 前端技术
tags: JavaScript ES6
---

* content
{:toc}
  对ES6中的一些知识要点，常用特性做一个梳理。







* Let、const的暂时性死区

  使用let声明的变量只在let所在的的代码块内有效，且不存在变量提升，如果先使用再用let声明变量会报错。

  ​

  当一个块级作用域中存在let,const时，它便会绑定这一区域，在这一区域内，在声明前使用变量就会报错，这就是暂时性死区。

  ```
  if (true) {
    // TDZ开始
    tmp = 'abc'; // ReferenceError
    console.log(tmp); // ReferenceError

    let tmp; // TDZ结束
    console.log(tmp); // undefined

    tmp = 123;
    console.log(tmp); // 123
  }
  ```

  有些暂时性死区是不易被发现的例如
  ```
  function bar(x = y, y = 2) {
    return [x, y];
  }

  bar(); // 报错
  ```
  ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。

  总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

* 块级作用域
  ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。

  第一种场景，内层变量可能会覆盖外层变量。
  ```
  var tmp = new Date();

  function f() {
   console.log(tmp);
    if (false) {
      var tmp = 'hello world';
    }
  }

  f(); // undefined
  ```
  上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。

  第二种场景，用来计数的循环变量泄露为全局变量。
  ```
  var s = 'hello';

  for (var i = 0; i < s.length; i++) {
   console.log(s[i]);
  }

  console.log(i); // 5
  ```
  上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。

  let实际上为 JavaScript 新增了块级作用域。
  ```
  function f1() {
    let n = 5;
    if (true) {
      let n = 10;
    }
    console.log(n); // 5
  }
  ```
  上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是10。


  块级作用域与函数声明

  函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。

  ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。

  ```
  // 情况一
  if (true) {
    function f() {}
  }

  // 情况二
  try {
    function f() {}
  } catch(e) {
    // ...
  }
  ```

  上面两种函数声明，根据 ES5 的规定都是非法的。

  但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。

  ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于`let`，在块级作用域之外不可引用。

## 箭头（Arrow）

`=>` 是function的简写形式，支持`expression` 和 `statement `两种形式。同时一点很重要的是它拥有词法作用域的this值，帮你很好的解决this的指向问题，这是一个很酷的方式，可以帮你减少一些代码的编写，先来看看它的语法。

```
([param] [, param]) => {
   statements
}

param => expression

```

然后再来看看例子，以及babel 编译后的结果。

ES6:

![img](https://segmentfault.com/img/bVmlvZ)

babel编译后结果：

![img](https://segmentfault.com/img/bVmlv1)