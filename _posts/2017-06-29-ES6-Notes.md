---
layout: post
title:  "ES6知识要点及常用特性梳理"
date:   2017-06-29 13:20:00
categories: 前端技术
tags: JavaScript ES6
---

* content
{:toc}
  对ES6中的一些知识要点，常用特性做一个梳理。







* Let、const的暂时性死区

  使用let声明的变量只在let所在的的代码块内有效，且不存在变量提升，如果先使用再用let声明变量会报错。

  ​

  当一个块级作用域中存在let,const时，它便会绑定这一区域，在这一区域内，在声明前使用变量就会报错，这就是暂时性死区。

  ```
  if (true) {
    // TDZ开始
    tmp = 'abc'; // ReferenceError
    console.log(tmp); // ReferenceError

    let tmp; // TDZ结束
    console.log(tmp); // undefined

    tmp = 123;
    console.log(tmp); // 123
  }
  ```

  有些暂时性死区是不易被发现的例如
  ```
  function bar(x = y, y = 2) {
    return [x, y];
  }

  bar(); // 报错
  ```
  ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。

  总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

* 块级作用域
  ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。

  第一种场景，内层变量可能会覆盖外层变量。
  ```
  var tmp = new Date();

  function f() {
   console.log(tmp);
    if (false) {
      var tmp = 'hello world';
    }
  }

  f(); // undefined
  ```
  上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。

  第二种场景，用来计数的循环变量泄露为全局变量。
  ```
  var s = 'hello';

  for (var i = 0; i < s.length; i++) {
   console.log(s[i]);
  }

  console.log(i); // 5
  ```
  上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。

  let实际上为 JavaScript 新增了块级作用域。
  ```
  function f1() {
    let n = 5;
    if (true) {
      let n = 10;
    }
    console.log(n); // 5
  }
  ```
  上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是10。


  块级作用域与函数声明

  函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。

  ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。

  ```
  // 情况一
  if (true) {
    function f() {}
  }

  // 情况二
  try {
    function f() {}
  } catch(e) {
    // ...
  }
  ```

  上面两种函数声明，根据 ES5 的规定都是非法的。

  但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。

  ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于`let`，在块级作用域之外不可引用。

## 箭头（Arrow）

`=>` 是function的简写形式，支持`expression` 和 `statement `两种形式。同时一点很重要的是它拥有词法作用域的this值，帮你很好的解决this的指向问题，这是一个很酷的方式，可以帮你减少一些代码的编写，先来看看它的语法。

```
([param] [, param]) => {
   statements
}

param => expression

```

然后再来看看例子，以及babel 编译后的结果。

ES6:

![img](https://segmentfault.com/img/bVmlvZ)

babel编译后结果：

![img](https://segmentfault.com/img/bVmlv1)

## 类（class）

ES6 引入了class（类），让javascript的面向对象编程变得更加容易清晰和容易理解。类只是基于原型的面向对象模式的语法糖。

```
  class Animal {
    // 构造方法，实例化的时候将会被调用，如果不指定，那么会有一个不带参数的默认构造函数.
    constructor(name,color) {
      this.name = name;
      this.color = color;
    }
    // toString 是原型对象上的属性
    toString() {
      console.log('name:' + this.name + ',color:' + this.color);

    }
  }
   
 var animal = new Animal('dog','white');
 animal.toString();

 console.log(animal.hasOwnProperty('name')); //true
 console.log(animal.hasOwnProperty('toString')); // false
 console.log(animal.__proto__.hasOwnProperty('toString')); // true

 class Cat extends Animal {
  constructor(action) {
    // 子类必须要在constructor中指定super 方法，否则在新建实例的时候会报错.
    // 如果没有置顶consructor,默认带super方法的constructor将会被添加、
    super('cat','white');
    this.action = action;
  }
  toString() {
    console.log(super.toString());
  }
 }

 var cat = new Cat('catch')
 cat.toString();
 
 // 实例cat 是 Cat 和 Animal 的实例，和Es5完全一致。
 console.log(cat instanceof Cat); // true
 console.log(cat instanceof Animal); // true
```

### 类的 `prototype` 属性和 `__proto__` 属性

在上一篇 [javascript面向对象编程](http://segmentfault.com/a/1190000002900676#articleHeader3) 中我们已经了解到一个实例化对象会有一个 `__proto__` 指向构造函数的 `prototype` 属性。在`class` 中。同时具有 `__proto__` 和 `prototype` 两个属性，存在两条继承链。

- 子类的 `__proto__` 属性，表示构造函数的继承，总是指向父类。
- 子类的 prototype 的 `__proto__` 属性表示方法的继承，总是指向父类的 `prototype` 属性。

```
  class Cat extends Animal {}
  console.log(Cat.__proto__ === Animal); // true
  console.log(Cat.prototype.__proto__ === Animal.prototype); // true
 
```

我们先来看第一条 `Cat.__proto__ === Animal` 这条原型链。完成构造函数继承的实质如下：

```
 class Cat extends Animal {
   construcotr() {
     return Animal.__proto__.call(this);
  }
 }
```

第二条对原型链 `Cat.prototype.__proto__ === Animal.prototype` 完成方法的继承，实质如下：

```
Cat.prototype.__proto__ = Animal.prototype
```

另外还有还有三种特殊情况。

```
 class A extends Object {}
 console.log(A.__proto__ === Object); // true
 console.log(A.prototype.__proto__ === Object.prototype); 
 
```

A继承Object，A的__prototype__ 指向父类Object. A的 `prototype.__proto__` 指向父类Object的prototype。

从上篇文章中的 [函数对象的原型](http://segmentfault.com/a/1190000002900676#articleHeader5) 中我们可以了解到，函数是一种特殊的对象，所有函数都是 `Function` 的实例。

```
 class Cat {}
 console.log(Cat.__proto__ === Function.prototype); //true
 console.log(Cat.prototype.__proto__ === Object.prototype); //true
```

由于Cat不存在任何继承，就相当于一个普通函数，由于函数都是`Function` 的实例，所以 `Cat.__proto__`指向 Function.prototype. 第二条继承链指向父类（Function.prototype） 的prototype属性，所以 `Cat.prototype.__proto__ === Object.prototype`. Cat调用后会返回Object实例，所以 `A.prototype.__proto__` 指向构造函数（Object）的prototype。

```
 class Cat extends null {};
 console.log(Cat.__proto__ === Function.prototype); // true;
 console.log(Cat.prototype.__proto__ === null); //true

```

Cat是一个普通函数，所以继承 `Function.prototype` .第二条继承链不继承任何方法，所以 `Cat.prototype.__proto__ == null`.